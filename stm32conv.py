from cmsis_svd.parser import SVDParser
import datetime
import os.path
import sys
import argparse


def fileinfo(desc):
    now = datetime.datetime.now()
    print("/*")
    print("    John Berg @ netbasenext.nl")
    print("")
    print("    %s" % (desc))
    print()
    print("    autogenerated on %s" % (now.strftime("%d.%m.%Y %H:%M")))
    print("")
    print("/*")
    print("")


def fileheader():
    fname, ext = os.path.splitext(__file__)
    ext = ".hpp"
    fname = os.path.join(fname + ext)
    if os.path.isfile(fname):
        with open(fname, 'r') as fin:
            print(fin.read(), end="")


def classheader(description, base=""):
    result = "\n/*\n"
    if base == "":
        result += "    %s\n" % (comment(description))
    else:
        result += "    %s @ %s\n" % (comment(description), base)
    result += "*/\n"
    return result


def comment(s):
    return " ".join(s.replace("\n", "").split())


def registerclass(typename, enumname, base, register):
    if register.address_offset < 256:
        ofs = ("0x%02x" % register.address_offset).upper()
    else:
        ofs = ("0x%04x" % register.address_offset).upper()
    base = "%s + %s" % (base, ofs)
    struct = classheader(register.description, base)
    struct += "struct %s : public reg32bit<%s>\n" % (typename, enumname)
    struct += "{\n"
    struct += "    using reg32bit::operator =;\n"
    struct += "    using reg32bit::operator |=;\n"
    struct += "\n"
    for field in register.fields:
        tp = ("Property<%s, %s, %s> %s;" % (base, field.bit_offset, field.bit_width, field.name)).ljust(55)
        struct += "    %s // %s\n" % (tp, comment(field.description))
    struct += "};\n"
    print(struct)


def enumclass(name, fields):
    bitOffset = 0
    print("")
    print("enum class %s" % (name))
    print("{")
    for field in fields:
        if bitOffset == field.bit_offset:
            tp = ("    %s," % (field.name)).ljust(30)
        else:
            tp = ("    %s = %s," % (field.name, field.bit_offset)).ljust(30)
            bitOffset = field.bit_offset

        print("%s // %s" % (tp, comment(field.description)))
        bitOffset = bitOffset + 1
    print("};")


def generateGpioBase(peripheral):
    struct = classheader(peripheral.description)
    struct += "struct GPIO\n"
    struct += "{\n"
    peripheral.registers.sort(key=lambda x: x.address_offset)
    for register in peripheral.registers:
        tp = ("    regrw %s;" % (register.name)).ljust(50)
        struct += "%s // %s\n" % (tp, comment(register.description))
    struct += "};\n"
    print(struct)


def generateGpioDerived(peripheral):
    base = ("0x%08x" % peripheral.base_address).upper()
    struct = "struct %s : public GPIO\n" % (peripheral.name)
    struct += "{\n"
    struct += "    void *operator new(size_t) {return reinterpret_cast<void *>(%s);}\n" % (base)
    struct += "};\n"
    print(struct)


def run(family, mcu, headers=True):
    parser = SVDParser.for_packaged_svd(family, mcu)
    device = parser.get_device()

    device.peripherals.sort(key=lambda x: x.name)

    if headers:
        fileinfo(comment(device.description))
        fileheader()

    # pass 1: handle multiple instances of the same class
    gpioGenearted = False
    for peripheral in device.peripherals:
        if peripheral.name[:4] != 'GPIO':
            continue
        if not gpioGenearted:
            generateGpioBase(peripheral)
            gpioGenearted = True

        generateGpioDerived(peripheral)

    # pass 2: handle specials
    for peripheral in device.peripherals:
        if peripheral.name[:4] == 'GPIO':
            continue

        base = ("0x%08x" % peripheral.base_address).upper()
        struct = classheader(peripheral.description, base)
        struct += "struct %s\n" % (peripheral.name)
        struct += "{\n"
        for register in peripheral.registers:
            register.fields.sort(key=lambda x: x.bit_offset)
            # for now, if we have only 1 field, assume its 32 bits
            if len(register.fields) == 1:
                tp = ("    regrw %s;" % (register.name)).ljust(30)
                struct += "%s // %s\n" % (tp, comment(register.description))
            else:
                enumname = "%s_%s" % (peripheral.name, register.name)
                typename = enumname.lower()
                tp = ("    %s %s;" % (typename, register.name)).ljust(30)
                struct += "%s // %s\n" % (tp, comment(register.description))
                enumclass(enumname, register.fields)
                registerclass(typename, enumname, base, register)

        struct += "\n"
        struct += "    void *operator new(size_t) {return reinterpret_cast<void *>(%s);}\n" % (base)
        struct += "};\n"
        print(struct)
        # break


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='SVD to C++ header converter')
    parser.add_argument('inputfile')
    parser.add_argument('-o', '--outfile', nargs='?', type=argparse.FileType('w'), help='send output to file, as a header')
    args = parser.parse_args()
    name, ext = os.path.splitext(args.inputfile)
    if ext == "":
        ext = ".svd"

    stdout = sys.stdout
    if args.outfile:
        sys.stdout = args.outfile

    run("STMicro", os.path.join(name + ext))
    run("ARM", "ARMCM0.svd", False)
    sys.stdout = stdout
    print("done")
